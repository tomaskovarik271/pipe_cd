// functions/graphql-gateway/context.ts
// Note: Uses @supabase/ssr
import { createServerClient, parseCookieHeader } from '@supabase/ssr';
import type { HandlerEvent, HandlerContext } from '@netlify/functions'; // Types should now be available
import type { SupabaseClient, User } from '@supabase/supabase-js'; // Import types from core package

// Define Database types (e.g., generated by Supabase CLI)
// TODO: Generate these types using 'supabase gen types typescript --local > lib/db-types.ts'
//       and import them properly.
interface Database { public: { /* ... your DB types ... */ } }

// Environment Variables - Ensure these are set in Netlify and local .env
const supabaseUrl = process.env.SUPABASE_URL;
const supabaseAnonKey = process.env.SUPABASE_ANON_KEY;

// Match interface used in codegen.ts
export interface MyContext {
  supabaseClient: SupabaseClient<Database>;
  currentUser: User | null;
  // Add other context items if needed (e.g., Inngest client)
}

// Context function adapted for Netlify Functions and @supabase/ssr
export async function createContext({ event, context }: { event: HandlerEvent; context: HandlerContext }): Promise<MyContext> {
  if (!supabaseUrl || !supabaseAnonKey) {
    throw new Error('Missing Supabase URL or Anon Key environment variables');
  }

  // Parse cookies into an array: { name: string; value?: string }[]
  const parsedCookies = parseCookieHeader(event.headers.cookie || '');
  // Convert to a simple key-value object for the Supabase client
  const cookieStore: Record<string, string> = parsedCookies.reduce((acc, cookie) => {
    if (cookie.value !== undefined) {
        acc[cookie.name] = cookie.value;
    }
    return acc;
  }, {} as Record<string, string>);

  let currentUser: User | null = null;

  const supabaseClient = createServerClient<Database>(supabaseUrl, supabaseAnonKey, {
    cookies: {
      get(name: string): string | undefined {
        return cookieStore[name];
      },
      // Set/Remove are placeholders for serverless, as we rely on client-side storage
      // Netlify Functions don't typically handle setting response cookies directly in this manner.
      set(name: string, value: string, options) {
        // console.log('Context: Set cookie called (noop in serverless)', name);
      },
      remove(name: string, options) {
        // console.log('Context: Remove cookie called (noop in serverless)', name);
      },
    },
  });

  // Prefer fetching user from Authorization header JWT for stateless API calls
  const authHeader = event.headers.authorization;
  const token = authHeader?.startsWith('Bearer ') ? authHeader.split('Bearer ')[1] : null;

  if (token) {
    // console.log('Attempting to get user from token');
    const { data: { user }, error } = await supabaseClient.auth.getUser(token);
    if (error) {
      // console.error('Error fetching user by token:', error.message);
      // Potentially invalid token, treat as unauthenticated
      currentUser = null;
    } else {
       currentUser = user;
       // console.log('User fetched from token:', !!currentUser);
    }
  }
  // Fallback: attempt to get user from cookies if no header present (less common for API routes)
  else if (event.headers.cookie) {
     // console.log('Attempting to get user from cookies');
     const { data: { user }, error } = await supabaseClient.auth.getUser();
      if (error) {
          // console.error('Error fetching user by cookie:', error.message);
          currentUser = null;
      } else {
          currentUser = user;
          // console.log('User fetched from cookie:', !!currentUser);
      }
  } else {
      // console.log('No token or cookie found');
  }

  return { supabaseClient, currentUser };
} 